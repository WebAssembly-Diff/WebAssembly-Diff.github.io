<!DOCTYPE html>
<html lang="en">
  <head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">

    <title>WasmDiff |  </title>
    <meta name="description" content>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    

    <!-- fonts -->
    <link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700" rel="stylesheet">
    <link href="//fonts.googleapis.com/css?family=Ubuntu:300,400,500,600,700" rel="stylesheet">

    <!-- stylesheets -->
    <link rel="stylesheet" href="/style/doc.css">

    <!-- favicon -->
    <link rel="icon" href="/images/favicon.ico">

    

  </head>
  <body>

   <script>window.__INITIAL_STATE__ = {"page":{"path":"Discrepancy-examples.html","title":""},"data":{"navigation":{"logo":{"text":"Documentation for WasmDiff","type":"link","path":"index.html"},"main":[{"text":"WasmDiff: An automated discrepancy detection tool between native and Wasm","type":"label"},{"text":"INTRODUCTION","type":"label"},{"text":"Discrepancy examples","type":"link","path":"Discrepancy-examples.html"},{"text":"Getting Started","type":"link","path":"index.html#Getting-Started"},{"text":"Source code","type":"label"},{"text":"Github","type":"link","path":"https://github.com/WebAssembly-Diff/WasmDiff"}]}},"config":{"timezone":"UTC","root":"/","time_format":"HH:mm:ss","theme":"../node_modules/hexo-theme-doc","theme_config":{"swagger_ui":{"version":2,"permalinks":true,"api_explorer":true,"download":"Download specification","show_extensions":false,"deep_linking":true,"display_operation_id":false,"doc_expansion":"none"},"search":{"skip":false,"background":false,"route":"/lunr.json"},"favicon":"images/favicon.ico"}}}</script>

    <div id="react-navigation-root"><div class="doc-navigation" data-reactroot><nav class="doc-navbar"><a href="/index.html" class="doc-navbar__logo"><img src="/images/logo.png" class="doc-navbar__logo__img"><span class="doc-navbar__logo__text">Documentation for WasmDiff</span></a><i class="dc-icon dc-icon--close dc-icon--interactive doc-sidebar-close doc-navbar__sidebar-close doc-navbar__sidebar-close--desktop"></i><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-navbar__sidebar-toggle"></i></nav><nav class="doc-sidebar"><div class="doc-sidebar__vertical-menu"><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-sidebar-toggle--primary doc-sidebar__vertical-menu__item"></i><i class="dc-icon dc-icon--search dc-icon--interactive doc-sidebar__vertical-menu__item doc-sidebar__vertical-menu__item--primary"></i></div><div class="doc-sidebar-content"><div class="doc-sidebar__search-form"></div><ul class="doc-sidebar-list"></ul></div></nav></div></div>
    <div class="doc-content">
  <div class="dc-page">
    <div class="dc-card">
      <div id="react-search-results-root"></div>
      <div id="page-content" class="doc-formatting">
        <h1 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h1><blockquote>
<p>A representative sample of each type of discrepancy is selected for illustration.</p>
</blockquote>
<h2 id="1-Different-standard-library"><a href="#1-Different-standard-library" class="headerlink" title="1. Different standard library"></a>1. Different standard library</h2><h3 id="1-1-Wide-characters"><a href="#1-1-Wide-characters" class="headerlink" title="1.1 Wide characters"></a>1.1 Wide characters</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHAR_STRING <span class="meta-string">"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WIDE_STRING <span class="meta-string">L"BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *data;</span><br><span class="line">data = (<span class="keyword">void</span> *)CHAR_STRING;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string*/</span></span><br><span class="line"><span class="keyword">size_t</span> dataLen = <span class="built_in">strlen</span>((<span class="keyword">char</span> *)data);</span><br><span class="line"><span class="keyword">void</span> *dest1 = (<span class="keyword">void</span> *)alloca((dataLen + <span class="number">1</span>) * <span class="number">1</span>);</span><br><span class="line"><span class="keyword">void</span> *dest2 = (<span class="keyword">void</span> *)alloca((dataLen + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="keyword">wchar_t</span>));</span><br><span class="line"></span><br><span class="line">(<span class="keyword">void</span>)<span class="built_in">strcpy</span>(dest1, data);</span><br><span class="line">(<span class="keyword">void</span>)wcscpy(dest2, data);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (dest1 != <span class="literal">NULL</span> &amp;&amp; dest2 != <span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, (<span class="keyword">char</span> *)dest1);</span><br><span class="line">    wprintf(<span class="string">L"%ls\n"</span>, (<span class="keyword">char</span> *)dest2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The above code is compiled into x86 binary and wasm binary. We run both of them and The results show that the x86 binary value prints CHAR_STRING consisting of 43 characters A once, while the wasm binary prints both of the CHAR_STRING and the WIDE_STRING. </p>
<p>In the C standard, each FILE stream has an associated “orientation” (either “byte” or “wide”). The orientation is set by the first operation performed on it and can be inspected with the fwide function. So when the prinf on line x is successfully output, the FILE stream is already set to “byte” mode. Therefore, wprintf fails in x86. </p>
<p>This mechanism is defined by the standard C library. However, we compiled wasm using the musl instead of the most popular glibc library. Through our investigation, differences in wide-stream implementations between the two standard C libraries have led to this discrepancy. When generating x86 bianary using musl-gcc compilation, the above discrepancy disappears.</p>
<h3 id="1-2-Different-malloc-free"><a href="#1-2-Different-malloc-free" class="headerlink" title="1.2 Different malloc/free"></a>1.2 Different malloc/free</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> * data;</span><br><span class="line"><span class="comment">/* Initialize data */</span></span><br><span class="line">data = <span class="literal">NULL</span>;</span><br><span class="line">data = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">100</span>*<span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line"><span class="keyword">if</span> (data == <span class="literal">NULL</span>) &#123;<span class="built_in">exit</span>(<span class="number">-1</span>);&#125;</span><br><span class="line"><span class="built_in">free</span>(data);</span><br><span class="line"><span class="comment">/* POTENTIAL FLAW: Possibly freeing memory twice */</span></span><br><span class="line"><span class="built_in">free</span>(data);</span><br></pre></td></tr></table></figure>
<p>This code performs two free operations on an address allocated empty by the malloc function, a typical C illegal operation called double-free. Running this code under x86 will cause the program to crash, which is pretty much what we expected. Wasm, on the other hand, will have no effect when performing a double-free operation.</p>
<h3 id="1-3-Different-puts-put"><a href="#1-3-Different-puts-put" class="headerlink" title="1.3 Different puts/put"></a>1.3 Different puts/put</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">fputs</span>(<span class="string">"string"</span>, <span class="built_in">stdout</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">    printLine(<span class="string">"fputs failed!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>When the above code is executed in x86 binary, it will output the string “string”, while wasm binary will output the string “stringfputs failed!“. It looks like in wasm binary, the fputs function still returns 0 if it succeeds.</p>
<p>The above differences are due to the different C standard libraries. In x86, we used the most widely used glibc to compile the above code, while for wasm we used the musl standard library, which is officially supported by wasm. In glibc, a return value of fputs less than or equal to zero means that the function is in error, whereas in musl this criterion is less than zero. Since the conditional judgment statements in the code are only compatible with the glibc library implementation, wasm makes a difference when running this code.</p>
<h3 id="1-4-Different-printf-vprintf-nprintf-…"><a href="#1-4-Different-printf-vprintf-nprintf-…" class="headerlink" title="1.4 Different printf/vprintf/nprintf/…"></a>1.4 Different printf/vprintf/nprintf/…</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"%s\n"</span>);</span><br></pre></td></tr></table></figure>
<p>A mismatch between the arguments to the fprintf function and the format is clearly an illegal behavior. The above code prints some garbage characters in x86, while wasm prints the string “(null)”</p>
<p>After our investigation, this is still due to the differences between the glibc and musl C standard libraries. The different implementations of fprintf between the two standard libraries resulted in fprintf in musl adding security against parameter lists that don’t match the format, rather than leaving pointers open to leakage as in glibc.</p>
<h3 id="1-5-Different-rand"><a href="#1-5-Different-rand" class="headerlink" title="1.5 Different rand"></a>1.5 Different rand</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> data;</span><br><span class="line">data = (<span class="keyword">char</span>)RAND32();</span><br><span class="line"><span class="keyword">if</span>(data &lt; <span class="number">0</span>) <span class="comment">/* ensure we won't have an overflow */</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> result = data * <span class="number">2</span>;</span><br><span class="line">    printHexCharLine(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>In C, the rand() function uses a linear congruential generator as a generator to generate pseudo-random numbers, which can be seeded by the srand() function to ensure that the same seed generates the same sequence of random numbers.</p>
<p>In our experiments, we uniformly set the seed of all rand() functions to 1. However, we found that due to the different implementations of rand() by glibc and musl, they produce different sequences of random numbers for the same seed. So in the above code x86 binary and wasm binary print different hexes.</p>
<h3 id="1-6-Different-file-related-implementation"><a href="#1-6-Different-file-related-implementation" class="headerlink" title="1.6 Different file-related implementation"></a>1.6 Different file-related implementation</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FILE * data;</span><br><span class="line">data = <span class="literal">NULL</span>; <span class="comment">/* Initialize data */</span></span><br><span class="line">data = fopen(<span class="string">"BadSource_fopen.txt"</span>, <span class="string">"w+"</span>);</span><br><span class="line"><span class="comment">/* POTENTIAL FLAW: Close the file in the source */</span></span><br><span class="line">fclose(data);</span><br><span class="line"><span class="comment">/* POTENTIAL FLAW: Close the file in the sink (it may have been closed in the Source) */</span></span><br><span class="line">fclose(data);</span><br></pre></td></tr></table></figure>
<p>The x86 binary crashes because it frees the same address twice. wasm is different, it crashes on the first free because the fopen() function fails to create the file. Since wasm in wasi-libc does not operate on the local filesystem in the same way as the native code, fopen fails to create a file, causing the first subsequent free to report an error.</p>
<h2 id="2-Security-protections"><a href="#2-Security-protections" class="headerlink" title="2. Security protections"></a>2. Security protections</h2><h3 id="2-1-Lack-of-stack-protection"><a href="#2-1-Lack-of-stack-protection" class="headerlink" title="2.1 Lack of stack protection"></a>2.1 Lack of stack protection</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * data;</span><br><span class="line">data = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">/* FLAW: Allocate memory without using sizeof(int) */</span></span><br><span class="line">data = (<span class="keyword">int</span> *)alloca(<span class="number">10</span>);&#123;</span><br><span class="line">    <span class="keyword">int</span> source[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">/* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */</span></span><br><span class="line">    <span class="built_in">memcpy</span>(data, source, <span class="number">10</span>*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,data[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The above code uses the alloca function to allocate space on the stack for the int pointer data. However, since alloca accepts the number of bytes to be allocated, it allocates only 2.5 ints of space for data (an int takes up 4 bytes). In the subsequent memcpy operation, a one-time copy of 10*sizeof(int), that is, 40 bytes to data will undoubtedly cause buffer overflow.</p>
<p>But in wasm, the program does not prevent this operation; on the contrary, the memcpy operation is successfully executed. Instead, the memcpy operation is performed successfully, i.e., all 40 bytes after the data pointer are filled with the value 0.</p>
<p>On x86 platforms, the code is compiled with some stack-protection mechanisms such as canary or fortify. compilers such as gcc or clang also provide stack-protection options such as “-Wstack-protector”, “-fstack-protector”, and so on. These protections prevent non-writable parts of the stack from being modified.</p>
<p>However, in wasm, its stack is just a portion of contiguous space in a linear memory, and wasm itself does not provide an associated stack protection mechanism. </p>
<p>Although the design principles of wasm suggest that even without these protection mechanisms, relevant buffer overflow operations will not affect wasm’s local or global variables, and since wasm’s own functions are called by indexes rather than by addresses, relevant stack overflow attacks will not affect wasm’s security, but the lack of relevant stack protection will lead to the confusion of stack frames inside the program, which will lead to more possibilities of discrepancy.</p>
<h3 id="2-2-Lack-of-heap-protection"><a href="#2-2-Lack-of-heap-protection" class="headerlink" title="2.2 Lack of heap protection"></a>2.2 Lack of heap protection</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> * data;</span><br><span class="line">data = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">/* FLAW: Did not leave space for a null terminator */</span></span><br><span class="line">data = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">10</span>*<span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line"><span class="keyword">if</span> (data == <span class="literal">NULL</span>) &#123;<span class="built_in">exit</span>(<span class="number">-1</span>);&#125;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> source[<span class="number">10</span>+<span class="number">1</span>] = SRC_STRING;</span><br><span class="line">    <span class="comment">/* POTENTIAL FLAW: data may not have enough space to hold source */</span></span><br><span class="line">    <span class="built_in">strcpy</span>(data, source);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s"</span>,data)</span><br><span class="line">    <span class="built_in">free</span>(data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The string copy operation on the line 9 copies the array source, which has 11 bytes, to the array data, which has 10 bytes of space, causing a buffer overflow. Since wasm does not have a heap protection mechanism, illegal heap operations that would have crashed in x86 can be successfully executed in wasm.</p>
<h3 id="2-3-Lack-of-memory-protection"><a href="#2-3-Lack-of-memory-protection" class="headerlink" title="2.3 Lack of memory protection"></a>2.3 Lack of memory protection</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> data;</span><br><span class="line"><span class="keyword">int</span> buffer[<span class="number">10</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;data);</span><br><span class="line"><span class="keyword">if</span>(data &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">    buffer[data] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">"%d"</span>,buffer[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The above code, if run in x86, will cause the instruction “buffer[data]” on line x to access an address outside the stack if the input value is a very large value (e.g. 123456), resulting in a segmentation fault signal. But wasm binary does not show any exception for this illegal operation.</p>
<p>In Linux systems, there usually exists some means of memory protection at the hardware level. When a process tries to access some restricted area, the kernel sends a signal to the corresponding area to terminate the process. The classic example is the segmentation fault.</p>
<p>However, in wasm, since its memory is just a contiguous linear array, there is no paging mechanism and no corresponding hardware memory protection mechanism. The input value “123456” is also out of the range of the stack of wasm binary, but it happens to be within the memory range of wasm, so the write operation is successfully executed.</p>
<h2 id="3-Execution-environment"><a href="#3-Execution-environment" class="headerlink" title="3. Execution environment"></a>3. Execution environment</h2><h3 id="3-1-Uninitialised-data"><a href="#3-1-Uninitialised-data" class="headerlink" title="3.1 Uninitialised data"></a>3.1 Uninitialised data</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> data;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lf"</span>,data);</span><br></pre></td></tr></table></figure>
<p>For printing uninitialized variables, x86 binary outputs some random values while wasm always outputs 0. Since wasm is initialized to 0 for all unused memory, this leads to the discrepancy of the above illegal code.</p>
<h3 id="3-2-Size-of-pointers"><a href="#3-2-Size-of-pointers" class="headerlink" title="3.2 Size of pointers"></a>3.2 Size of pointers</h3><p>This category appears in PC2W because our fuzzer only compares the output and does not check the return value of the function, so it does not detect this category of discrepancy.</p>
<h3 id="3-3-Size-of-numbers"><a href="#3-3-Size-of-numbers" class="headerlink" title="3.3 Size of numbers"></a>3.3 Size of numbers</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> longNumber;</span><br><span class="line">longNumber = strtol(<span class="string">"0xfffffffff"</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%li\n"</span>, longNumber);</span><br></pre></td></tr></table></figure>
<p>The above code runs as follows: x86 binary outputs 68719476735(0xF FFFF FFFF) while wasm binary outputs 2147483647(0x7 FFF FFFF).</p>
<p>Wasm defaults to a 32-bit platform, so it will forcibly truncate the long integer that strtol is converted to to 32 bits and place the highest position at 0 (indicating a positive number).</p>
<h3 id="3-4-Different-running-environment"><a href="#3-4-Different-running-environment" class="headerlink" title="3.4 Different running environment"></a>3.4 Different running environment</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printLine(getenv(<span class="string">"PATH"</span>));</span><br></pre></td></tr></table></figure>
<p>The <code>getenv</code>function can be used to access the executable’s environment variables. In the native binary, the environment is inherited from the process that launched it, and it contains environment variables defined by the user (e.g., PATH).</p>
<h3 id="3-5-Different-memory-layout"><a href="#3-5-Different-memory-layout" class="headerlink" title="3.5 Different memory layout"></a>3.5 Different memory layout</h3><p><u>This category appears in PC2W, and the results of our analysis extend this category:3.6,3.7,3.8</u></p>
<h3 id="3-6-Different-memory-size"><a href="#3-6-Different-memory-size" class="headerlink" title="3.6 Different memory size"></a>3.6 Different memory size</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INT_MAX       2147483647</span></span><br><span class="line"><span class="keyword">int</span> data, *intPointer;</span><br><span class="line"><span class="keyword">size_t</span> i;</span><br><span class="line">data = INT_MAX / <span class="number">2</span> + <span class="number">2</span>; <span class="comment">/* 1073741825 */</span></span><br><span class="line">intPointer = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(data * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="keyword">if</span> (intPointer == <span class="literal">NULL</span>) &#123;<span class="built_in">exit</span>(<span class="number">-1</span>);&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; (<span class="keyword">size_t</span>)data; i++)&#123;</span><br><span class="line">    intPointer[i] = <span class="number">0</span>; <span class="comment">/* Potentially writes beyond the boundary of intPointer */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s"</span>,intPointer[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">free</span>(intPointer);</span><br></pre></td></tr></table></figure>
<p>In the above code, the for loop needs to do (size_t)data, which is 1073741825 times(nearly 4GB). </p>
<p>In x86, this number is still within the normal range of values that a program can request, so it doesn’t report an error; in wasm, however, the memory range is roughly 16 Gigabytes, so the above for loop behaves normally in x86 and generates out of bounds memory access in wasm.</p>
<h3 id="3-7-Different-stack-management-mechanism"><a href="#3-7-Different-stack-management-mechanism" class="headerlink" title="3.7 Different stack-management mechanism"></a>3.7 Different stack-management mechanism</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * data;</span><br><span class="line"><span class="keyword">int</span> source[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">size_t</span> i;</span><br><span class="line"><span class="comment">/* FLAW: Allocate memory without using sizeof(int) */</span></span><br><span class="line">data = (<span class="keyword">int</span> *)alloca(<span class="number">10</span>);</span><br><span class="line"><span class="comment">/* POTENTIAL FLAW: Possible buffer overflow if data was not allocated correctly in the source */</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">    data[i] = source[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>,data[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure>
<p>The above code uses the wrong parameter 10 instead of 10*sizeof(int) when allocating space for the pointer data using alloca in the fifth line, resulting in a buffer overflow in the subsequent for loop. Because this overflow operation doesn’t write many illegal addresses, the program doesn’t report an error in x86, and its prints the value of data[0] 0. But in wasm, the program gets stuck directly at the for loop.</p>
<p>In wasm binary, the variable size_t i within the loop is allocated at a location only 12 bytes away from the start of data. The fact that i is too close to the start address of data in memory causes the program to fall into an infinite loop by modifying i to 0 on the fourth for loop even though the above code doesn’t overflow much.</p>
<h2 id="4-Different-compilation"><a href="#4-Different-compilation" class="headerlink" title="4. Different compilation"></a>4. Different compilation</h2><h3 id="4-1-Different-optimization"><a href="#4-1-Different-optimization" class="headerlink" title="4.1 Different optimization"></a>4.1 Different optimization</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">char</span> *<span class="title">helperBad</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> charString[] = <span class="string">"helperBad string"</span>;</span><br><span class="line">    <span class="comment">/* FLAW: returning stack-allocated buffer */</span></span><br><span class="line">    <span class="keyword">return</span> charString;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CWE562_Return_of_Stack_Variable_Address__return_buf_01_bad</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    printLine(helperBad());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>In x86, the compiler detects that charString is a temporary variable inside a function and simply replaces the return value of helperBad with NULL. wasm does not, so x86 binary outputs nothing and wasm prints a string “<strong>helperBad st��</strong>“.</p>
<p>In x86, the compiler identified charString as a local variable, so directly replace its return value for NULL.But in wasm, with the same optimization parameter of O2, emscripten does not take the same optimization but replaces the last few characters of charString with some unprintable binary content.</p>
<h3 id="4-2-Different-compilation-results"><a href="#4-2-Different-compilation-results" class="headerlink" title="4.2 Different compilation results"></a>4.2 Different compilation results</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printLine</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * line)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(line != <span class="literal">NULL</span>) </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, line);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> * data, dataBadBuffer[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">char</span> source[<span class="number">10</span>+<span class="number">1</span>] = <span class="string">"AAAAAAAAAA"</span></span><br><span class="line"><span class="keyword">size_t</span> i, sourceLen;</span><br><span class="line">data = dataBadBuffer;</span><br><span class="line">data[<span class="number">0</span>] = <span class="string">'\0'</span>; <span class="comment">/* null terminate */</span></span><br><span class="line">sourceLen = <span class="built_in">strlen</span>(source);</span><br><span class="line"><span class="comment">/* Copy length + 1 to include NUL terminator from source */</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; sourceLen + <span class="number">1</span>; i++)&#123;</span><br><span class="line">    data[i] = source[i];</span><br><span class="line">&#125;</span><br><span class="line">printLine(data);</span><br></pre></td></tr></table></figure>
<p>The above code overflows the array by one byte in the subsequent for loop due to the use of the array dataBadBuffer with a length of 10 instead of 11. However, this operation does not necessarily affect the operation of the program because it does not necessarily overwrite the key address. In X86, the program printed ten capital A’s normally, while wasm printed nothing.</p>
<p>The following instruction is used in wasm to load the printLine function:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">local.get $var2</span><br><span class="line">i32.load offset=44</span><br><span class="line">local.set $var37</span><br><span class="line">local.get $var37</span><br><span class="line">call $printLine</span><br></pre></td></tr></table></figure>
<p>The value of \$var2 is 65484 and the address of dataBadBuffer is 65474. We can see that the address of char* data is set to (\$var2 + 44) = 65484. Before the main loop is run, the value of this address is set to the address of dataBadBuffer, which is 65474. Because the loop copies 11 bytes starting from the address of dataBadBuffer, the first byte of the value at (\$var2 + 44) is overwritten with the null byte terminator, \00. When the call to \$printLine is reached, the corrupted address pointed to by (\$var2 + 44) is a location with the value 00, so it acts as the end of a string. As a result, nothing is printed.</p>
<p>Due to the different compilation results, here wasm produces very strange compilation errors.</p>
<h3 id="4-3-Different-variable-initialization-methods"><a href="#4-3-Different-variable-initialization-methods" class="headerlink" title="4.3 Different variable initialization methods"></a>4.3 Different variable initialization methods</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SOURCE_STRING <span class="meta-string">"abc/opqrstu"</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func_A</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> string1[] = SOURCE_STRING;</span><br><span class="line">    <span class="keyword">char</span> string2[] = SOURCE_STRING;</span><br><span class="line">    <span class="keyword">char</span> * slashInString1;</span><br><span class="line">    <span class="keyword">size_t</span> indexOfSlashInString1;</span><br><span class="line">    slashInString1 = <span class="built_in">strchr</span>(string1, <span class="string">'/'</span>);</span><br><span class="line">    <span class="keyword">if</span> (slashInString1 == <span class="literal">NULL</span>)&#123;<span class="built_in">exit</span>(<span class="number">1</span>);&#125;</span><br><span class="line">    <span class="comment">/* FLAW: should be slashInString1 - string1 */</span></span><br><span class="line">    indexOfSlashInString1 = (<span class="keyword">size_t</span>)(slashInString1 - string2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%u\n"</span>,indexOfSlashInString1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The second-to-last line of the above code uses the wrong decremented number, resulting in indexOfSlashInString1 not pointing to the ‘/‘ in string1 as expected. In x86 the program outputs 4294967287 while in wasm it outputs 19.</p>
<p>When a subtraction operation is performed, the result of <code>indexOfSlashInString1</code> depends on how far apart string1 and string2 are in memory because the subtractor is the wrong string(should be string1).  In x86, this value is -9; in wasm, it is 19. So in X86, the result of <code>indexOfSlashInString1</code> will be considered as 18446744073709551607, but when printf() uses “%u” 32-bit format to print, so the final output result is 4294967287.</p>
<p>This discrepancy arises because the C standard does not specify how local variables inside a function are initialized. The order in which variables are initialized on the stack may not be consistent with the order in which they are initialized in the code. Some variables are even initialized using registers rather than on the stack. In the above code, x86 initializes str2 while wasm initializes str1, which is why the result of the subtraction operation on line 10 is positive for one and negative for the other.</p>

        <div id="react-support-footer-root"></div>
      </div>
    </div>
  </div>
</div>

    


    

    <!-- js vendors -->
    <script src="//code.jquery.com/jquery-3.2.1.min.js" crossorigin="anonymous"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/lunr.js/2.1.0/lunr.min.js"></script>

    <!-- js source  -->
    <script src="/script/doc.js"></script>

    

  </body>
</html>
